= Design document

== Explicit non-goals

- Permission managament, user verification
- GUI

== Inter-project knowledge sharing challanges

- Reluctance to give up the power that comes with knowledge

== Architecture

=== Wit servers in federation

#figure(image("architecture-concept1.svg", fit: "contain", height: 80%), caption: [
    Wit operating in client-server architecture in federation with other servers.
]) <architecture_concept1>

Challenges of the architecture described by @architecture_concept1:
- Recording a single version between the servers
- Validating local links against other servers in federation
- Connecting reliably servers within the federation

Benefits of the architecture described by @architecture_concept1:
- Limited access to files managed by other projects
- Connflicts cannot occur as files are not shared

=== Git-like distribution with single remote

#figure(image("architecture-concept2.svg", fit: "contain", height: 70%), caption: [
    Wit operating just like git.
]) <architecture_concept2>

Challenges of the architecture described by @architecture_concept2:
- Limiting access to files managed by other projects
- Limiting the amount of data cloned into a single project
- Conflicts can occur

== Federation communication protocol

// #figure(image("communication-protocol1.svg"))

Addressing challenges of architecture in @architecture_concept1:
- use *version vector*, *version stamps*, *interval tree clocks* or a mix of those
    utilizing the hashes generated by git (*hash histories* maybe?)
- allow failure of any server in federation by either:
    - forcing the user to wait for a server to be available before validating a link
    - forcing the user to remove a link to unresponsive server
    - ignoring potentially broken links
    (all of which is similar to how the Internet operates.)

Challenges not addressed yet:
- do we keep locally the data from other servers that was made available to us at some point?

== Link syntax

```
wit://[<remote-name>][@<version>]/<file-path>[#<file-section>]
```

== User personas

Each user persona will be built of short paragraphs explaining their goals, purpose and approach.

+ *Goals* - What they want?
+ *Purpose* - Why they want it?
+ *Approach* - How they want to achieve it?


=== Software Developer working on a project that depends on other projects

- The developer wants to view the wiki in a *state appropiate to the version of their project*. 
    It is important to them as they might be at the moment amending an older version of the product 
    and it is not desired to apply, for example, newer requirements to it. They plan to achieve that by setting
    their git repository to appropiate version.
- The developer wants to make sure that when they create links they are valid references to the parts of the
    wiki that are maintained as part of other projects. They want it such way because they need to be aware of
    significant changes to the documents they are referencing as those might invalidate what they were about to
    write on pages managed by them. They would like to be *informed of invalid links* each time they are about to
    publish changes, preferably by an IDE extension but optionally by execution of a CLI utility that can be included
    in CI/CD pipelines or invoked on demand.
- The developer wants to see managed by them wiki files *alongside the git repository* they are working on.
    They want it so because their IDE is the most familiar and comfortable working environment for them and having
    wiki in the same repository as the code will reduce the burden of a context switch between source code and
    documentation. They plan to achieve that by having the wiki in a subdirectory of their source code repository.
- The developer wants to easily *initialize the wiki* in a new project they are working on which depends on other
    projects. *They do not want the integration between projects to slow them down*. They will achieve that by using
    a solution that can federate with other other project's wikis and requires no shared infrastructure between
    projects.

=== Manager using the wiki to oversee knowledge-sharing between projects

- The manager wants to be able to browse the wiki in *pleasant graphical form*. It is important to them that the pages
    are presentable becease it makes learning from them a much more pleasant experience. They plan to browse the pages
    rendered to HTML through their *web browser* as that is most intuitive way of exploring wikis to them.
- The manager wants to be able to shut down any wiki *without affecting other project's wikis*. It's important to them
    that no data is lost even when something out of their control happens. They expect that shutting down permamently
    one of the wikis will not affect significantly other wikis in the network.



=== Commands overview

==== Git commands which can be mapped to wit

- *`git status` → `wit status`* - show uncommitted changes to the wiki 
    (while being in the project git repository operates as if within the submodule)
- *`git log` → `wit log`* - show history of changes to the wiki including available
    changes from other servers (pulls more information than `git log` run within submodule,
    utilizes the distributed nature of the servers)
- *`git add` → `wit add`*
- *`git commit` → `wit commit`* - saves changes in a commit in both the submodule and the
    project git repository and the submodule (default mode of operation)
- *`git pull` → `wit pull`* 
- `git checkout` → `wit checkout`
- *`git init` → `wit init`* - starts a new wiki submodule in the git repository storing the project
- *`git clone` → `wit clone`*

==== Wit specific commands

- *`wit view`* - open in the browser the wiki at the state matching the repository
- *`wit validate`* - validate references/links, should be installed by default as a local
    git hook when initializing the wit submodule
    

